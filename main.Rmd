---
title: "Sustainable logging - main document"
output: 
  html_document:
    theme: journal
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE, 
                      root.dir = rprojroot::find_rstudio_root_file())
calc_data = FALSE

# load libraries
library(knitr)
library(kableExtra)
library(data.table)
library(ggplot2)
library(parallel)

rerun = FALSE   ## if true, heavy codes will be rerun to recalculate results; if false, results will be loaded from previously saved data
```

# Timber recovery model



# Defining sustainability of logging 

## Exploring timber volume trajectories

We will first test 5 scenarios and look at the predicted trajectories. The location stays the same (here we use Manaus coordinates in central Amazonia).

Four input variables differ among scenarios: 

- the logging intensity (in m$^3$ha$^{-1}$)

- the length of the logging cycle (in years)

- $\omega 0$: the pre-logging proportion of commercial timber 

- $dti$: the pre-logging disturbance factor (between 0 and 1): when $dti=0$, the site has suffered no human disturbance previous to logging; if $dti=1$, the site has been completely disturbed and clearcut. 

```{r}
timeLength = 1000
logIntensity = rep(10, 5); logIntensity[2] = 30
logCycle = rep(35, 5); logCycle[3] = 65
omega0 = rep(0.90, 5); omega0[4] = 0.30
longitude = rep(-60.6, 5) ## location: Manaus
latitude = rep(-3.3, 5)
dti = rep(0.10, 5); dti[5] = 0.40
tabScenario = data.table(scenario = c("default", "highIntensity", "longCycle", "lessCommSpecies", "prevDisturb"), 
                         logIntensity, logCycle, omega0, dti)
```



The following table summarizes the 5 scenarios and the values of each input variable. 

```{r}
tabScenario %>%
  kable() %>%
  kable_styling()
```

The following figure shows the predicted trajectory of timber volume stocks for each of the 5 scenarios. 

```{r illustr_traj_uncert, fig.height=4, fig.width=10}

source("functions/timbRecovery.R")

recov = timbRecovery(timeLength, logIntensity, logCycle, omega0, longitude, latitude, dti, uncertainties = TRUE)

dfrecov = recov[[1]]
dfrecov$scenario = tabScenario$scenario[dfrecov$site]

ggplot(dfrecov, aes(x=t, y = med, color = scenario, ymin = inf, ymax = sup)) + 
  geom_ribbon(aes(fill = scenario), colour = NA, alpha = 0.1) + geom_line() + theme(legend.position = "none") +
  xlab("Time since first logging event (yr)") + ylab("Commercial timber volume (m3/ha)")  + facet_wrap(~scenario)

```

The following figure shows the predicted trajectory of timber volume stocks for each of the 5 scenarios. 

```{r illustr_vextReal_uncert, fig.height=2, fig.width=10}
vextReal = data.table(recov[[2]])
vextReal$scenario = tabScenario$scenario[vextReal$site]

ggplot(vextReal, aes(x = ncycle, y = med, color = scenario, ymin = inf, ymax = sup)) + 
  geom_ribbon(aes(fill = scenario), colour = NA, alpha = 0.1) + geom_line() + theme(legend.position = "none") +
  facet_wrap(~scenario, nrow = 1) + xlab("Number of cutting cycles") + ylab("Volume extracted")
```

Only the "longCycle" scenario maintains high levels of timber volume and a constant production after 1000 years. 

## What criteria for sustainability? 




# What affects sustainability

For now we consider logging sustainable if the production (max-likelihood) stays constant during the first 100 cycles. 

```{r}
timeLength = 1000

tabScenario = data.table(expand.grid(logIntensity = seq(5,35,5), 
                                     logCycle = seq(10,100,10), 
                                     omega0 = seq(0.1,1,0.1), 
                                     dti = seq(0,0.7,0.1)))
tabScenario$longitude = -60.6
tabScenario$latitude = -3.3

if (calc_data) {
  recov = timbRecovery(timeLength, tabScenario$logIntensity, 
                       tabScenario$logCycle, tabScenario$omega0, 
                       tabScenario$longitude, tabScenario$latitude, 
                       tabScenario$dti, uncertainties = FALSE)
  
  vextReal = data.table(tabScenario, recov[[2]])
  
  dfSustain = vextReal[,.(pVextTot = sum(vextReal)/(logIntensity*last(ncycle))), .(logIntensity, logCycle, omega0, dti)]
  save(dfSustain, file = "Rdata_files/dfvext_sustain_manaus.Rdata")
  
} else load("Rdata_files/dfvext_sustain_manaus.Rdata")

```

## Logging cycle and intensity

The following picture shows the proportion of extracted volume compared to the expected logging intensity over the first 100 cycles. If this proportion is 1, then logging can be considered sustainable. 

First we use a "perfect conditions" scenario with $\omega_0 = 1$ (all species are commercial) and that $dti = 0$ (no pre-logging anthropogenic disturbance). 

```{r, fig.height = 3, fig.width=5}
dfSustain$sustainable = (dfSustain$pVextTot > 0.99)

ggplot(subset(dfSustain, omega0==1 & dti == 0) ) + 
  geom_raster(aes(x = logIntensity, y = logCycle, fill = pVextTot)) + 
  theme(aspect.ratio=1) 
ggplot(subset(dfSustain, omega0==1 & dti == 0) ) + 
  geom_raster(aes(x = logIntensity, y = logCycle, fill = sustainable)) + 
  theme(aspect.ratio=1) 
```

## Proportion of commercial species (ie changing $\omega_0$)

```{r, fig.height = 4, fig.width=10}
dfSustain$lab_omega0 = factor(dfSustain$omega0)
levels(dfSustain$lab_omega0) = paste0("omega0 = ", as.numeric(levels(dfSustain$lab_omega0))*100, "%")

ggplot(subset(dfSustain,dti == 0) ) + 
  geom_raster(aes(x = logIntensity, y = logCycle, fill = sustainable)) + 
  theme(aspect.ratio=1) + facet_wrap( ~ lab_omega0, nrow = 2)
```

## Effect of adding prelogging anthropogenic disturbances (ie changing $dti$)

```{r, fig.height = 4, fig.width=10}
ggplot(subset(dfSustain, omega0 == 1) ) + 
  geom_raster(aes(x = logIntensity, y = logCycle, fill = sustainable)) + 
  theme(aspect.ratio=1) + facet_wrap( ~ paste0("dti = ", dti*100, "%"), nrow = 2)
```


## Location

For now we consider logging sustainable if the production (max-likelihood) stays constant during the first 100 cycles. 

```{r}
timeLength = 1000

coordinates = data.table(siteName = c("Itoupe", "Paragominas", "RioBranco", "Iquitos"), 
                         longitude = c(-53.6, -47.4, -68, -73.4), 
                         latitude = c(3.5, -3.0, -10, -3.75))
tabScenario = data.table(expand.grid(logIntensity = seq(5,35,5), 
                                     logCycle = seq(10,100,10), 
                                     omega0 = seq(0.2,1,0.2), 
                                     dti = seq(0,0.6,0.2), 
                                     siteName = coordinates$siteName))
tabScenario = merge(tabScenario, coordinates, by = "siteName") 

if (calc_data) {
  recov = timbRecovery(timeLength, tabScenario$logIntensity, 
                       tabScenario$logCycle, tabScenario$omega0, 
                       tabScenario$longitude, tabScenario$latitude, 
                       tabScenario$dti, uncertainties = FALSE)
  
  vextReal = data.table(tabScenario, recov[[2]])
  dfvextReal = melt(vextReal, id.vars = colnames(tabScenario), variable.name = "ncycle", value.name = "vext")
  dfvextReal$ncycle = as.numeric(gsub("V", "", dfvextReal$ncycle))
  
  dfSustain_sites = dfvextReal[,.(pVextTot = sum(vext)/(logIntensity*last(ncycle))), .(logIntensity, logCycle, omega0, dti, siteName)]
  save(dfSustain_sites, file = "Rdata_files/dfvext_sustain_sites.Rdata")
  
} else load("Rdata_files/dfvext_sustain_sites.Rdata")

load("Rdata_files/dfvext_sustain_manaus.Rdata")

dfSustain$siteName = "Manaus"
dfSustain = subset(dfSustain, !(omega0 %in% seq(0.1,9,0.2)) &
                     !(dti %in% seq(0.1,0.5,0.2)))
dfSustain = rbind(dfSustain, dfSustain_sites)
```


### Changing the proportion of commercial species

```{r, fig.height = 10, fig.width=10}
dfSustain$sustainable = (dfSustain$pVextTot > 0.99)

dfSustain$lab_omega0 = factor(dfSustain$omega0)
levels(dfSustain$lab_omega0) = paste0("omega0 = ", as.numeric(levels(dfSustain$lab_omega0))*100, "%")

ggplot(subset(dfSustain,dti == 0) ) + 
  geom_raster(aes(x = logIntensity, y = logCycle, fill = sustainable)) + 
  theme(aspect.ratio=1) + facet_grid( siteName ~ lab_omega0)
```

### Changing pre-logging maturity

```{r, fig.height = 10, fig.width=10}
ggplot(subset(dfSustain, omega0 == 1) ) + 
  geom_raster(aes(x = logIntensity, y = logCycle, fill = sustainable)) + 
  theme(aspect.ratio=1)  + facet_grid( siteName ~ paste0("dti = ", dti*100, "%"))
```


# How much longer can we harvest at current rates? 

```{r available area}

timeLength <- 200

prod_target <- 35 * 1e6

if (rerun) {
  
  load("variables and parameters/areaLogging.Rdata")
  
  ## offset can be either logging intensity (20 m3/ha) or logging cycle length (35 years)
  logIntensity_med <- 20
  logCycle_med <- 35
  
  ## estimate the corresponding intensity/cycle to reach the production target
  ## 2 options: with forests currently available for logging or with all unprotected forests
  logCycle_calc <- floor(sum(areaLogging$areaTot * 100 * areaLogging$pCurrentAvail) * logIntensity_med / prod_target)  ## (*100): km2 -> ha
  logCycle_calc_max <- floor(sum(areaLogging$areaTot * 100 * areaLogging$pNotProtect) * logIntensity_med / prod_target)
  
  logIntensity_calc <- floor(logCycle_med * prod_target / sum(areaLogging$areaTot * 100 * areaLogging$pCurrentAvail))  ## (*100): km2 -> ha
  logIntensity_calc_max <- floor(logCycle_med * prod_target / sum(areaLogging$areaTot * 100 * areaLogging$pNotProtect))
  
  ## create the data table with all variables combinations
  dfVariables = data.table(logIntensity = c(rep(logIntensity_med, 2), logIntensity_calc, logIntensity_calc_max), 
                        logCycle = c(logCycle_calc, logCycle_calc_max, rep(logCycle_med, 2)), 
                        scenario = rep(c("current","roadBuilding"), 2), 
                        offSet = rep(c("intens","cycle"), each = 2), id = 1:4)
  dfVariables = merge(dfVariables, expand.grid(id = 1:4, omega0 = seq(0.2, 1, 0.2)), by = "id")
  
  areaLogging$site = 1:nrow(areaLogging)
  areaLogging_melt = melt(data.table(areaLogging), id.vars = c("long","lat","areaTot","site"), 
                          variable.name = "scenario", value.name = "pArea", variable.factor = TRUE)
  levels(areaLogging_melt$scenario) = c("current","roadBuilding")
  
  source("functions/timbRecovery.R")
  
  # Calculate the number of cores
  no_cores <- detectCores() - 2
  
  # Initiate cluster
  cl <- makeCluster(no_cores)
  
  clusterEvalQ(cl, library(data.table))
  
  clusterExport(cl, varlist = c("timbRecovery", "dfVariables", "timeLength", "areaLogging_melt", "rtruncnorm"))
  
  recovChangOmega <- parSapply(cl, 1:nrow(dfVariables), function(i) {
    
    df_area = subset(areaLogging_melt, scenario == dfVariables$scenario[i])
    recov = timbRecovery(timeLength, logIntensity = dfVariables$logIntensity[i], 
                         logCycle = dfVariables$logCycle[i], omega0 = dfVariables$omega0[i], 
                         longitude = df_area$long, latitude = df_area$lat, 
                         area = df_area$areaTot*df_area$pArea)
    return(recov)
    
  })
  
  stopCluster(cl)
  
  volumeVarAm = do.call(rbind, lapply(1:nrow(dfVariables), function(i) data.table(recovChangOmega[[1,i]], idVar = i)))
  dfVariables$idVar = 1:nrow(dfVariables)
  volumeVarAm = merge(volumeVarAm, dfVariables[,-"id"], by = "idVar")
  
  vextVarAm = do.call(rbind, lapply(1:nrow(dfVariables), function(i) data.table(recovChangOmega[[2,i]], idVar = i)))
  dfVariables$idVar = 1:nrow(dfVariables)
  vextVarAm = merge(vextVarAm, dfVariables[,-"id"], by = "idVar")
  
  save(volumeVarAm, vextVarAm, file = "Rdata_files/timeToEsgote.Rdata")
  
} else { load("Rdata_files/timeToEsgote.Rdata") }


## annualise harvests 

annualise = function(X, period, X0) {
  mat = matrix(X0 / period, ncol = length(X), nrow = period)
  for (i in 1:period) {
    mat[i, i:length(X)] = X[1:(length(X)-i+1)]/period
  }
  return(colSums(mat))
}

volumeVarAm_ann = volumeVarAm[order(t) , .(inf = annualise(inf, logCycle, first(inf)), 
                                           med = annualise(med, logCycle, first(inf)), 
                                           sup = annualise(sup, logCycle, first(inf)), t), 
                              .(idVar,logIntensity, logCycle, scenario, offSet, omega0)]
```


```{r, fig.height=4, fig.width = 12}

volumeVarAm_ann$omega0 = factor(volumeVarAm_ann$omega0)
levels(volumeVarAm_ann$omega0) = paste0("Commercial: ",as.numeric(levels(volumeVarAm_ann$omega0))*100,"%")

volumeVarAm_ann$offSet = factor(volumeVarAm_ann$offSet)
levels(volumeVarAm_ann$offSet) = c("Cycle = 35 yrs", "Intensity = 20 m3/ha")

volumeVarAm_ann$scenario = factor(volumeVarAm_ann$scenario)
levels(volumeVarAm_ann$scenario) = c("Currently available","All unprotected")

ggplot(volumeVarAm_ann, aes(x=t, y = med/1e8, ymin = inf/1e8, ymax = sup/1e8, colour = offSet, fill = offSet)) + geom_line() + 
  facet_grid( scenario ~ omega0, scales = "free")  + geom_ribbon(alpha = 0.2, colour = NA) + labs(x = "Time (yrs)", y = "Timber volume stocks (Mm3/ha)")
```


```{r, fig.height=4, fig.width = 12}
vextVarAm$omega0 = factor(vextVarAm$omega0)
levels(vextVarAm$omega0) = paste0("Commercial: ",as.numeric(levels(vextVarAm$omega0))*100,"%")

vextVarAm$offSet = factor(vextVarAm$offSet)
levels(vextVarAm$offSet) = c("Cycle = 35 yrs", "Intensity = 20 m3/ha")

vextVarAm$scenario = factor(vextVarAm$scenario)
levels(vextVarAm$scenario) = c("Currently available","All unprotected")

ggplot(vextVarAm, aes(x=(ncycle-1)*logCycle, y = med/logCycle/1e8, ymin = inf/logCycle/1e8, ymax = sup/logCycle/1e8, 
                      colour = offSet, fill = offSet)) + geom_line() + 
  facet_grid( scenario ~ omega0)  + geom_ribbon(alpha = 0.2, colour = NA) + labs(x = "Time (yrs)", y = "Timber production (Mm3/yr)")

```

> In many cases timber production is way under the 35 Mm3/yr target because many grid cells do not have enough timber (especially when only 20% of the volume is commercial). 

> Optimise timber intensities to reach target? 
