---
title: "Sustainability of Brazilian forest concessions"
output: 
  bookdown::word_document2:
  fig_caption: yes
  keep_md: true
bibliography: myBiblio.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE, results='hide', 
                      root.dir = rprojroot::find_rstudio_root_file())
# load libraries
packages_needed <- c("knitr", "data.table", "ggplot2", "parallel", "sp", "truncnorm")
packages_to_install <- packages_needed[!( packages_needed %in% rownames(installed.packages()))]
if (length(packages_to_install) > 0)
  install.packages(packages_to_install)
lapply(packages_needed, require, character.only = TRUE)

## source all functions
file.sources = list.files(path = "R/", pattern="*.R", full.names = TRUE)
sapply(file.sources, source, .GlobalEnv)

if (!dir.exists("cache"))
  dir.create("cache")
```

# Introduction

Since the 1970s, selective logging has established itself as the main silvicultural system in tropical regions. This system is based on very simple rules: the exploitation of a few commercial trees having reached a minimum cutting diameter and letting the forest recover during a rotation period generally between 25 and 35 years. In the Amazon, selective logging regulations typically set a rotation cycle of 20 to 35 years with a logging intensity varying from 15 to 30 m$^3$ of harvested timber per ha. However, several studies showed that under such extraction regimes, less than 50% of the timber extracted can recover within this rotation duration [@Sist2007;@Putz2012]. A recent study simulating the timber recovery in all the region confirmed this result and showed that even under long rotation cycles of 65 years and a logging intensity of 20 m$^3$.ha$^{-1}$, logged forests could recover at most 70% of their initial timber [@Piponiot2019a]. Current harvest regimes can only be sustained over multiple cycles if high-value slow-growing hardwoods are replaced by species of fast growth and low density, which are very little valued in the current market [@Alder2000;@Keller2004;@Phillips2004a;@VanGardingen2006;@Schulze2008b].

Although reduced impact logging techniques were seen as a promising alternative to reduce the damage of logging and consequently to improve timber volume recovery [@Schulze2008b], most of the studies assessing the long-term impacts of such techniques in the tropics - including the Amazon - showed that timber volume will recover at best 50% of its pre-logging value within the rotation cycle duration fixed by legislation [@Sist2007;@Putz2012;@DeAvila2017].

Despite the low recovery of timber stocks in logged forests, selective logging is still a widespread and economically viable land use in the Amazon. Around 75% of the five hundred million ha of forests are still intact [@Potapov2017] and have accumulated highly valuable timber over centuries. Moreover, illegal logging is widespread in the region and often results in forest degradation [@Brancalion2018;@Finer2014]: it is therefore difficult to assess the true state of Amazon forests, and their current potential for timber production. In the absence of changes in logging practices and enforcement of logging regulations, it is very likely that most logged forests will have a dramatic reduction in timber yields [@Putz2012;@Piponiot2019a], decreasing their chance of meeting the demand for timber products. 

In 2006, the Brazilian Forest Service (SFB) was created to implement a very ambitious system of long-term logging concessions [@Brazil2006]. The concession system set up by the SFB aims to provide a legal framework for sustainable timber production in the Amazon while reducing illegal logging and concentrating Amazonian timber production within those concessions. Today Brazilian forest concessions cover 1.5 million ha in the Amazon, with a maximum potential area estimated at 60 million ha [@Bomfim2016]. The current timber production in Brazilian forest concessions is 221 thousand m$^3$ per year, representing only 2% of the timber extracted in the Brazilian Amazon [@SFB2019]. The forest management system remains based on selective logging and the capacity of natural production forests of the Amazon under concession to meet rising demands for wood products on a long-term basis must be questioned urgently.

In this study we used an Amazon-wide timber recovery model developed by @Piponiot2019a to estimate the total timber volume that could be produced in Brazilian logging concessions under varying cycle lengths, logging intensities and pool of commercial species. We identified the conditions under which selective logging was sustainable from a timber production point of view and what its production capacity was in relation to the demand for wood. 

First, this paper aims to assess which logging regimes (logging intensity and rotation length) are sustainable, i.e. are able to ensure a long-term and constant timber production in the Brazilian Amazon. Second, based on the characteristics of the identified sustainable logging regimes and the potential area of forest concessions in the Brazilian Amazon, we assess if the potential annual timber production is in adequacy with the present timber demand estimated at 11 Mm$^3$.yr$^{-1}$ [@Vidal2020;@SFB2019].


# Methods

## Study areas - Brazilian concessions

Our study focuses on the Brazilian forest concessions. These concessions are located in public forests and currently cover an area of 1.55 Mha in the Brazilian Amazon, of which 1.05 Mha are federal concessions, managed by the SFB, and 0.5 Mha are managed by state-level agencies [@SFB2019]. We retrieved the map of federal concessions and the map of all public forests from the Brazilian Forest Service website [@SFB2020;@SFB2019a]. We defined the area of all potential concessions as the area of all public forests that (i) are in the Brazilian Amazon biome, (ii) are designated for sustainable use, and (iii) are not community forests, indigenous territories or military areas [as defined in @SFB2019, p. 112].  

```{r get-prop-concess}
if (!file.exists("data/pconcessions.Rdata")) {
  ## current concessions ####
  concessions <- rgdal::readOGR(dsn = "data_sfb/final", layer = "BRconc")
  # define new raster with resolution = 1 degree
  ext2 <- floor(raster::extent(concessions)) + c(0, 1, 0, 1)
  rst <- raster::raster(resolution = 0.01, ext = ext2)
  ## transform shapefile into raster with 1 degree resolution
  raster_concessions <- raster::rasterize(concessions, rst)
  raster_concessions2 <- !is.na(raster_concessions)
  pconcessions <- raster::aggregate(raster_concessions2, fact = 100)
  pconcessions <- raster::as.data.frame(pconcessions, xy = TRUE)
  colnames(pconcessions) <- c("long", "lat", "pConcess")
  
  ## all potential concessions ####
  flonas <- rgdal::readOGR(dsn = "data_sfb/final", layer = "BRflopub")
  # define new raster with resolution = 1 degree
  ext2 <- floor(raster::extent(flonas)) + c(0, 1, 0, 1)
  rst <- raster::raster(resolution = 0.01, ext = ext2)
  raster_flonas <- raster::rasterize(flonas, rst)
  raster_flonas2 <- !is.na(raster_flonas)
  pflonas <- raster::aggregate(raster_flonas2, fact = 100)
  pflonas <- raster::as.data.frame(pflonas, xy = TRUE)
  colnames(pflonas) <- c("long", "lat", "pFlona")
  
  pconcessions <- merge(pconcessions, pflonas, by = c("long", "lat"), all = TRUE)
  pconcessions[is.na(pconcessions$pConcess), "pConcess"] <- 0
  pconcessions <- subset(pconcessions, pConcess > 0 | pFlona > 0)
  save(pconcessions, file = "data/pconcessions.Rdata")
} else load("data/pconcessions.Rdata")
```

```{r map-brazil-concess, fig.height = 5, fig.width = 11}
concessions <- rgdal::readOGR(dsn = "data_sfb/final", layer = "BRconc")
flopub <- rgdal::readOGR(dsn = "data_sfb/final", layer = "BRflopub")
map.world <- rgdal::readOGR("D:/Mes Donnees/maps/borders/South_America", "South_America")
nbrasil.map <- raster::crop(map.world, y = raster::extent(-74, -44, -11,5))
plot(nbrasil.map, col = "#00000005")
plot(flopub, col = 4, border = NA, add = TRUE)
plot(concessions, col = 2, border = NA, add = TRUE)
legend("topright", fill=c(2,4), legend = c("Current concessions", "Potential concessions"))
``` 


```{r get-area-pixels}
raster_conc <- expand.grid(long = seq(min(pconcessions$long), max(pconcessions$long)), 
                           lat = seq(min(pconcessions$lat), max(pconcessions$lat)))
coordinates(raster_conc) <- ~long + lat
proj4string(raster_conc) <- CRS("+proj=longlat +datum=WGS84")
gridded(raster_conc) <- TRUE
areatot <- raster::area(raster::raster(raster_conc)) ## pixel area, in km2
raster_conc$area <- raster::extract(areatot, raster_conc)*100 ## km -> ha

pconcessions <- merge(pconcessions, 
                      as.data.frame(raster_conc), 
                      by = c("long", "lat"))

## all pixels with flonas (potential concessions): will be used in simulations
locations <- subset(pconcessions, pFlona > 0 | pConcess > 0)
locations$site <- 1:nrow(locations)
## multiply by factor pi = 8.2/(8.2+5.9)
## TODO add this to iterations as pi = rbeta(100, 8.2, 5.9)
pi = 8.2/(8.2+5.9)
locations$pConcess <- locations$pConcess*pi
locations$pFlona <- locations$pFlona*pi
```

The total area of current federal concessions is `r signif(sum(pconcessions$area*pconcessions$pConcess)/1e6, 3)` Mha, and the area of all potential concessions is `r signif(sum(pconcessions$area*pconcessions$pFlona)/1e6, 3)`. 

## The VDDE model 

In this study we used the volume dynamics with differential equations (VDDE) model [@Piponiot2018]. 
The VDDE model focuses on the total volume, i.e. the volume of all live trees with diameter at breast height (DBH) $\geq$ 50 cm (the standard minimum cutting size in the Amazon Basin). By contrast, only a portion of this volume is composed of commercial species and will be referred to as commercial volume. Two variables are explicitly modelled: the total volume and the proportion of commercial volume $\omega$, from which the commercial volume can be inferred. 

In this study, we defined three input variables, that can be set for each simulation: the logging intensity, the logging cycle length, and the initial proportion of commercial volume $\omega_0$. Low values of $\omega_0$ represent highly selective logging where only the most valuable species are logged; by contrast, high values of $\omega_0$ mean that most species are logged. 
Other parameters of the VDDE model are spatially defined at a 1 degree resolution. The model was calibrated at the Amazon Basin scale in a Bayesian framework with data from 3500 ha of forest plots, among which 845 ha are from 15 sites monitored for as long as 30 years after being subjected to selective logging [@Sist2015;@Piponiot2019a]. 

Each logging cycle is composed of two steps: (i) the logging itself is a function of the logging intensity and the characteristics of the forest; and (ii) the post-logging volume recovery phase is a function of the logging cycle length, and of the characteristics of the forest. The logging lowers the total volume and the proportion of commercial volume. The total volume and proportion of commercial species then increase during the recovery phase [@Piponiot2019a]. These two steps are sequentially repeated to simulate 200 years of logging cycles. 

Errors are propagated by drawing all parameter values from their calibrated distribution [from @Piponiot2019a], and simulating logging cycles with these parameter values. This process is repeated 100 times and summary statistics (median and 95% credibility interval) are calculated at each time step.  

## Testing scenarios

In this study we tested 54 different scenarios by using all combinations of the following inputs: (i) initial proportion of commercial volume: 20% (highly selective), 50% (intermediate) or 90% (not selective); (ii) logging intensity: 10 m$^3$.ha$^{-1}$ (low), 20 m$^3$.ha$^{-1}$ (intermediate) or 30 m$^3$.ha$^{-1}$ (high); (iii) length of cutting cycles: 20 years (short), 35 years (intermediate) or 60 years (long); (iv) concessions area: the area of current federal concessions, or the area of all potential concessions (see section: "Study areas"). 

For each scenario we simulated 1000 years of logging cycles, and determined the duration of sustained production $tsust$, i.e. the time when timber stocks not sufficient to maintain a constant timber production (Figure \@ref(fig:illust-sust-log)).
<!-- , with a 5% tolerance. -->
<!-- To do so, we assessed the timber extraction over all logged forests (either current or potential concessions) at each logging cycle; $tsust$ corresponds to the time when the median extracted timber (over all 100 iterations) is lower or equal to 95% of the target logging intensity.  -->

```{r illust-sust-log, fig.height = 4, fig.width = 8}
logCyc = 60
logInt = 10

dfsimu = simulateLogging(
  timeLength = 1000,
  logIntensity = logInt,
  logCycle = logCyc,
  omega0 = 0.5,
  uncertainties = FALSE,
  longitude = -60,
  latitude = 0
)
dfvol = dcast(subset(dfsimu, variable!="vextReal"), ncycle + trec ~ variable)
dfvol$vcom = dfvol$volume*dfvol$omega
dfcycle = dcast(dfvol, ncycle ~ trec, value.var = "vcom")
colnames(dfcycle) <- c("ncycle", "pl", "pr")
dfcycle[, pl := c(pl[-1], NA)]
dfvext = subset(dfsimu, variable=="vextReal")
tsust = max(dfvext[value==logInt, "ncycle"])*logCyc

ggplot() +
  geom_vline(xintercept = tsust, lty = 2) + 
  geom_line(data = dfvol, aes(x = trec+logCyc*(ncycle-1), y = vcom)) + 
  geom_segment(data = dfcycle, 
               aes(x = logCyc*ncycle, xend = logCyc*ncycle+1, 
                   yend = pl, y = pr), col = 4, lwd = 1) + 
  geom_segment(data = subset(dfcycle, ncycle >= max(dfvext[value==logInt, "ncycle"])), 
               aes(x = logCyc*ncycle, xend = logCyc*ncycle+1, 
                   yend = pl, y = pr), col = 2, lwd = 1) + 
  annotate(geom = "segment", x = 0, xend = tsust, y = 54, yend = 54,
           arrow = arrow(length = unit(0.2, "cm"), ends = "both")) +
  annotate(geom = "text", x = c(500, 800, 350), y = c(25, 8, 52), col = c(4,2, 1),
           label = c("Sustained\nproduction", "Timber depletion", 
                     "Duration of sustained production (tsust)")) +
  labs(x = "Time (yr)", y = "Commercial volume") + 
  theme_classic() + 
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) +
  expand_limits(y = c(0,55))
``` 

```{r define-simulations}
timeLength <- 200
omega0 <- c(0.2, 0.5, 0.9)
logIntensity <- (1:3)*10
logCycle <- c(20, 35, 60)
simulations <- expand.grid(omega0 = omega0, 
                           logIntensity = logIntensity, 
                           logCycle = logCycle)
simulations$simid <- 1:nrow(simulations)
```

```{r run-simulations}
if (!dir.exists("cache/simulations_concessionsBR/"))
  dir.create("cache/simulations_concessionsBR/")

all_i = 1:nrow(simulations)
del_i = as.numeric(gsub("recov|\\.Rdata", "", list.files("cache/simulations_concessionsBR/")))
missing_simus <- all_i[!all_i%in%del_i]

if (length(missing_simus) > 0) {
  source("R/simulateLogging.R")

  # Calculate the number of cores
  no_cores <- detectCores() - 2
  # Initiate cluster
  cl <- makeCluster(no_cores)
  clusterEvalQ(cl, library(data.table))
  clusterExport(cl, varlist = c("simulateLogging", "simulations", "timeLength", "locations", "rtruncnorm"))

  recovCycles <- parLapply(cl, missing_simus, function(j) {
    recov <- simulateLogging(
      timeLength = 1000,
      logIntensity = simulations$logIntensity[j],
      logCycle = simulations$logCycle[j],
      omega0 = simulations$omega0[j],
      longitude = locations$long,
      latitude = locations$lat,
      uncertainties = TRUE, keepAll = FALSE
    )
    save(recov, file = paste0("cache/simulations_concessionsBR/recov", j, ".Rdata"))
    return(recov)
  })

  stopCluster(cl)
}
```

```{r prepare-results}
outputs <- lapply(list.files("cache/simulations_concessionsBR/", full.name = TRUE), function(fnm){
  load(fnm)
  get("recov")
})
names(outputs) <- gsub("recov|\\.Rdata", "", list.files("cache/simulations_concessionsBR/"))

results <- rbindlist(outputs, idcol = "simid")
results$simid <- as.numeric(results$simid)

## multiply by total area ####
results <- merge(results, locations, by = "site")
results <- melt(results, measure.vars = c("pConcess", "pFlona"), 
                variable.name = "ppf", value.name = "pArea", value.factor = TRUE)
levels(results$ppf) <- c("current", "potential")
results <- subset(results, pArea > 0)
```

```{r get-timber-production}
dfvext <- subset(results, variable == "vextReal")
## multiply by area and sum (or mean for omega0)
dfvext <- dfvext[, .(lwr = sum(lwr*pArea*area),
                     med = sum(med*pArea*area), 
                     upr = sum(upr*pArea*area)), 
                 .(simid, ncycle, trec, ppf)]
# add simulation info
dfvext <- merge(dfvext, simulations, by = "simid")
```

```{r get-timber-stocks}
dfvolume <- subset(results, variable != "vextReal")
dfvolume <-
  dcast(dfvolume, value.var = c("lwr", "med", "upr"),
        ncycle + trec + simid + ppf + area + pArea + site ~ variable
  )
dfvolume$lwr <- dfvolume$lwr_omega*dfvolume$lwr_volume
dfvolume$med <- dfvolume$med_omega*dfvolume$med_volume
dfvolume$upr <- dfvolume$upr_omega*dfvolume$upr_volume
dfvolume <- dfvolume[, .(lwr = sum(lwr*pArea*area),
                         med = sum(med*pArea*area), 
                         upr = sum(upr*pArea*area)), 
                     .(simid, ncycle, trec, ppf)]
dfvolume <- dfvolume[, c("ncycle", "trec", "simid", "ppf", "lwr", "med", "upr")]
```

```{r add-volume0}
## add volume0
## initial maturity and volume
load("data/paramStan.Rdata")
dfPred <- spatialPars(locations[, c("long", "lat")], uncert = TRUE)
dfPred$dti <- sample(pars_dti, nrow(dfPred), replace = TRUE)

dfPred[, matInit := stem_mort ^ (-lambda_ti) * (1 - dti)]
dfPred[, vol0 := volume(matInit, aG_FORMIND, aM, bP, bM, theta)]

dfvol0 <- dfPred[, .(variable = "volume", 
                     lwr = quantile(vol0, 0.025), 
                     med = quantile(vol0, 0.5), 
                     upr = quantile(vol0, 0.975)), 
                 .(long, lat)]
dfvol0 <- merge(dfvol0, locations, by = c("long", "lat"))
dfvol0 <- melt(dfvol0, measure.vars = c("pConcess", "pFlona"), 
               variable.name = "ppf", value.name = "pArea", value.factor = TRUE)
levels(dfvol0$ppf) <- c("current", "potential")
dfvol0 <- subset(dfvol0, pArea > 0)
dfvol0 <- dfvol0[, .(lwr = sum(lwr*pArea*area), 
                     med = sum(med*pArea*area),
                     upr = sum(upr*pArea*area),
                     trec = 0, ncycle = 1), .(ppf)]

dfres <- expand.grid(ppf = c("current", "potential"), simid = simulations$simid)
dfres <- merge(dfres, simulations[, c("simid", "omega0")])
dfres <- merge(dfvol0, dfres, by = "ppf")
dfres[, `:=`(lwr = omega0*lwr, med = omega0*med, upr = omega0*upr)]
dfvolume <- rbind(dfvolume, dfres[, colnames(dfvolume), with = FALSE])
```

```{r annualize-volume}
dfvolume <- subset(dfvolume, trec != 1)
dfvolume <- merge(dfvolume, simulations, by = "simid")
dfvolume[, t := (ncycle-1)*logCycle + trec]
```



# Results

```{r calc-tsust}
dftsust <- lapply(outputs, function(df) { 
  df <- subset(df, variable == "vextReal")
  ## add site information
  df <- merge(df, locations, by = "site")
  df <- melt(df, measure.vars = c("pConcess", "pFlona"), 
             variable.name = "ppf", value.name = "pArea", 
             value.factor = TRUE)
  levels(df$ppf) <- c("current", "potential")
  df <- subset(df, pArea > 0)
  df[, `:=`(med = med*area*pArea, 
            lwr = lwr*area*pArea, 
            upr = upr*area*pArea)]
  df <- df[, .(lwr = sum(lwr), med = sum(med), upr = sum(upr)),
           .(ppf, ncycle)]
  ini <- df[ncycle==1, -"ncycle"]
  ini$variable <- "prodi"
  res <- rbind(ini, df[, .(lwr = max(ncycle[lwr>=0.95*lwr[ncycle==1]]), 
                           med = max(ncycle[med>=0.95*med[ncycle==1]]), 
                           upr = max(ncycle[upr>=0.95*upr[ncycle==1]]), 
                           variable="tsust"), .(ppf)])
  return(res)
})
dftsust <- rbindlist(dftsust, idcol = "simid")
dftsust$simid <- as.numeric(dftsust$simid)
dftsust <- merge(dftsust, simulations, by = "simid")
dftsust[variable == "tsust", `:=`(lwr = lwr*logCycle, 
               med = med*logCycle, 
               upr = upr*logCycle)]
dftsust = dcast(dftsust, omega0 + logIntensity + logCycle + ppf ~ variable, 
                value.var = c("lwr", "med", "upr"))
```

```{r tsust-vs-prodi, fig.width = 10, fig.height = 6, fig.caption= "Tradeoff between timber production and sustainability. "}
dftsust$ppf = factor(dftsust$ppf)
levels(dftsust$ppf) = c("Current concessions", "Potential concessions")
ggplot(dftsust, aes(x=med_tsust, y = med_prodi/1e6, 
                   xmin=lwr_tsust, ymin = lwr_prodi/1e6,
                   xmax=upr_tsust, ymax = upr_prodi/1e6, 
                   shape = paste0(omega0*100, "%"), 
                   color = paste(logIntensity, "m3/ha -", logCycle, "yr"))) +
  geom_pointrange() +
  geom_errorbarh() +
  facet_wrap(~ppf, scales = "free") +
  labs(x = "Duration of sustained production (yr)", 
       y = "Total production (Mm3/yr)", 
       shape = "Initial proportion of\ncommercial volume", 
       color = "Logging rules") +
  theme_classic() +
  theme(legend.position = "top") +
  guides(color = guide_legend(nrow=2)) 
```

```{r temp}
# ## subset to have only sustainable 
# sust_simus <- subset(fin_prod, variable == "prop" & med >=0.95 & silvTreat == 0)
# 
# table(sust_simus$logCycle, sust_simus$logIntensity)
# table(sust_simus$omega0)
# table(sust_simus$silvTreat)
# table(sust_simus$ppf)
# 
# sust_prodF <- subset(fin_prod, paste(ppf, simid) %in% paste(sust_simus$ppf, sust_simus$simid) & variable == "fin")
# sust_prodF[, `:=`(value = paste0(signif(med, 2)/1e6, " (", 
#                                  signif(lwr, 2)/1e6, "-",
#                                  signif(upr, 2)/1e6, ")"), 
#                   omega0 = paste0(omega0*100, "%"), 
#                   silvTreat = c("no", "yes")[(silvTreat>0) + 1])]
# sust_prodF <- dcast(sust_prodF, omega0 + logIntensity + logCycle + silvTreat ~ ppf)
# sust_prodF90 <- subset(sust_prodF, omega0 == "90%")
# max1 <- sust_prodF90[which.max(as.numeric(tstrsplit(current, " ")[[1]])), "current"]
# max2 <- sust_prodF90[which.max(as.numeric(tstrsplit(potential, " ")[[1]])), "potential"]
# sust_prodF50 <- subset(sust_prodF, omega0 == "50%")
# max3 <- sust_prodF50[which.max(as.numeric(tstrsplit(current, " ")[[1]])), "current"]
# max3b <- paste0(tstrsplit(max3, " ")[[1]], " (95% confidence interval: ", tstrsplit(max3, "\\(")[[2]])
# max4 <- sust_prodF50[which.max(as.numeric(tstrsplit(potential, " ")[[1]])), "potential"]
```

<!-- After 200 years, `r nrow(sust_simus)` scenarios (out of 54) kept a constant total volume production. When 50% of the initial volume is composed of commercial species, the maximum volume produced is `r max3b` Mm$^3$ in current forest concessions and `r max4` Mm$^3$ in all potential concessions (i.e. all available public forests; Table \@ref(tab:sust-production)).  -->
<!-- When 90% of the initial volume is composed of commercial species, `r max1` Mm$^3$ in current forest concessions and `r max2` Mm$^3$ in all potential concessions.  -->


<!-- ```{r sust-production, results = "asis"} -->
<!-- kable(sust_prodF[, c("omega0", "logIntensity", "logCycle", "current", "potential")],  -->
<!--       col.names = c("Commercial volume", "Log. int. (m3/ha)", "Log. cycle (yr)",  -->
<!--                     "Production in current concessions (Mm3/yr)",  -->
<!--                     "Production in potential concessions (Mm3/yr)"),  -->
<!--       caption = "Results of all sustainable scenarios. Sustainable scenarios are defined as the combination of input variables that result in a constant production of timber for the 200-yr simulations. The first 3 columns correspond to the input variables: the proportion of commercial volume (%); logging intensity (m$^3$.ha${^-1}$) and logging cycle length (yr). The 2 last columns correspond to the annual production of timber (Mm$^3$.yr$^{-1}$) under those scenarios, if current concessions or all potential concessions are used, respectively. NA means that the scenario was not sustainable under that definition of concession area (current or potential).") -->
<!-- ``` -->

```{r timber-stocks-br, fig.height=4, fig.width = 10, fig.cap="Commercial volume stocks in all potential concession areas for all sustainable scenarios."}
dfvol_fig <- subset(dfvolume, ppf == "potential")

dfvol_fig$omega0 = factor(dfvol_fig$omega0)
levels(dfvol_fig$omega0) = paste0("omega0 = ", as.numeric(levels(dfvol_fig$omega0))*100,"%")

dfvol_fig$silvTreat = factor(dfvol_fig$silvTreat)
levels(dfvol_fig$silvTreat) = paste0("Silv. effect = ", as.numeric(levels(dfvol_fig$silvTreat))*100,"%")

dfvol_fig$logrules <- paste("Cycle:", dfvol_fig$logCycle, "yrs; Intensity:", dfvol_fig$logIntensity, "m3/ha")

ggplot(dfvol_fig, aes(x=t, y = med/1e6)) + 
  geom_line(aes(colour = logrules)) +
  geom_ribbon(alpha = 0.2, colour = NA, 
              aes(fill = logrules, 
                  ymin = lwr/1e6, 
                  ymax = upr/1e6)) + 
  facet_grid( ~ omega0)  + 
  labs(x = "Time (yrs)", y = "Commercial volume (Mm3)") +
  theme_bw() + 
  theme(legend.position = "top") 
```

# References
